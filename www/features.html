<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
  <title>Clang - Features</title>
  <link type="text/css" rel="stylesheet" href="menu.css" />
  <link type="text/css" rel="stylesheet" href="content.css" />
  <style type="text/css">
</style>
</head>
<body>

<!--#include virtual="menu.html.incl"-->

<div id="content">

  <h1>Features of Clang</h1>
  <p>
  This page outlines the main goals of Clang, as well as some compelling reasons
  why you should consider using Clang. In the Goals section below, you will find
  a brief, bulleted overview of the goals and features that we are striving for
  in the development of Clang.  However, in the <a href="#keyfeatures">Key
  Features</a> section you will find a more detailed presentation on what we
  believe are some key drawing points for the Clang front-end.</p>

<h1><a name="keyfeatures">Key Features</a></h1>

There are several key features which we believe make Clang an exciting front-end.  These features are designed to make things easier for both the compiler developer (people working on Clang and derivative products) and the application developer (those who use Clang/LLVM).

<h2>Library based architecture</h2>
A major design concept for the LLVM front-end involves using a library based architecture.  In this library based architecture, various parts of the front-end can be cleanly divided into separate libraries which can then be mixed up for different needs and uses.  In addition, the library based approach makes it much easier for new developers to get involved and extend LLVM to do new and unique things.  In the words of Chris,
<div class="quote">"The world needs better compiler tools, tools which are built as libraries. This design point allows reuse of the tools in new and novel ways. However, building the tools as libraries isn't enough: they must have clean APIs, be as decoupled from each other as possible, and be easy to modify/extend. This requires clean layering, decent design, and keeping the libraries independent of any specific client."</div>
Currently, the LLVM front-end is divided into the following libraries:
<ul>
	<li>libsupport - Basic support library, reused from LLVM.
	<li>libsystem - System abstraction library, reused from LLVM.
	<li>libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction, file system caching for input source files. <span class="weak_txt">(depends on above libraries)</span>
	<li>libast - Provides classes to represent the C AST, the C type system, builtin functions, and various helpers for analyzing and manipulating the AST (visitors, pretty printers, etc). <span class="weak_txt">(depends on above libraries)</span>
	<li>liblex - C/C++/ObjC lexing and preprocessing, identifier hash table, pragma handling, tokens, and macros. <span class="weak_txt">(depends on above libraries)</span>
	<li>libparse - Parsing and local semantic analysis. This library invokes coarse-grained 'Actions' provided by the client to do stuff (e.g. libsema builds ASTs). <span class="weak_txt">(depends on above libraries)</span>
	<li>libsema - Provides a set of parser actions to build a standardized AST for programs. AST's are 'streamed' out a top-level declaration at a time, allowing clients to use decl-at-a-time processing, build up entire translation units, or even build 'whole program' ASTs depending on how they use the APIs. <span class="weak_txt">(depends on libast and libparse)</span>
	<li>libcodegen - Lower the AST to LLVM IR for optimization &amp; codegen. <span class="weak_txt">(depends on libast)</span>
        <li>librewrite - Editing of text buffers, depends on libast.</li>
        <li>libanalysis - Static analysis support, depends on libast.</li>
	<li><b>clang</b> - An example driver, client of the libraries at various levels. <span class="weak_txt">(depends on above libraries, and LLVM VMCore)</span>
</ul>
As an example of the power of this library based design....  If you wanted to build a preprocessor, you would take the Basic and Lexer libraries. If you want an indexer, you would take the previous two and add the Parser library and some actions for indexing. If you want a refactoring, static analysis, or source-to-source compiler tool, you would then add the AST building and semantic analyzer libraries.
In the end, LLVM's library based design will provide developers with many more possibilities.

<h2><a name="performance">Speed and Memory</a></h2>
Another major focus of LLVM's frontend is speed (for all libraries).  Even at this early stage, the clang front-end is quicker than gcc and uses less memory.<br>
<div class="img_container">
	<div class="img_title">Memory:</div>
	<img src="feature-memory1.png" />
	<div class="img_desc">This test was run using Mac OS X's Carbon.h header, which is 12.3MB spread across 558 files!
	Although large headers are one of the worst case scenarios for GCC, they are very common and it shows how clang's implemenation is significantly more memory efficient.
	</div>
</div>
<div class="img_container">
	<div class="img_title">Performance:</div>
	<img src="feature-compile1.png" />
	<div class="img_desc">Even at this early stage, the C parser for Clang is able to achieve significantly better performance.  Many optimizations are still possible of course.
	</div>
</div>
<div class="img_container">
	<div class="img_title">Performance:</div>
	<img src="feature-compile2.png" />
	<div class="img_desc">By using very trivial file-system caching, clang can significantly speed up preprocessing-bound applications like distcc.	<span class="img_notes">(<a href="clang_video-07-25-2007.html">more details</a>)</span>
</div>
</div>

<h2><a name="expressivediags">Expressive Diagnostics</a></h2>
Clang is designed to efficiently capture range information for expressions and statements, which allows it to emit very detailed diagnostic information when a problem is detected.<br>
<div class="img_container">
	<div class="img_title">Clang vs GCC:</div>
	<img src="feature-diagnostics1.png" />
	<div class="img_desc">There are several things to take note of in this example:
	<ul>
		<li>The error messages from Clang are more detailed.
		<li>Clang shows you exactly where the error is, plus the range it has a problem with.
	</ul>
	</div>
	<div class="img_notes"><span>Notes:</span>The first results are from clang; the second results are from gcc.</div>
</div>
<h2>Better Integration with IDEs</h2>
Another design goal of Clang is to integrate extremely well with IDEs. IDEs often have very different requirements than code generation, often requiring information that a codegen-only frontend can throw away.  Clang is specifically designed and built to capture this information.
</div>
</body>
</html>
