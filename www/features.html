<!-- Consulted: http://www.w3.org/TR/CSS1 & http://www.w3.org/TR/CSS21/ -->
<!--
Consulted:
HTML 4.01 specs: http://www.w3.org/TR/html401/
-->
<html>
<head>
	<title>Clang - Features</title>
	<link type="text/css" rel="stylesheet" href="menu.css" />
	<link type="text/css" rel="stylesheet" href="content.css" />
	<style type="text/css">
</style>
</head>
<body>
<!--#include virtual="menu.html.incl"-->
<div id="content">
	<h1>Features of Clang</h1>
This page outlines the main goals of Clang, as well as some compelling reasons why you should consider using Clang. In the "Goals" section below, you will find a brief, bulletted overview of the goals and features that we are striving for in the development of Clang.  However, in the "Key Features" section you will find a more detailed presentation on what we believe are some key drawing points for the LLVM front-end.  <span class="key_point">If you are new to Clang and the LLVM front-end, and you want a reason for considering working on or using the new front-end, then make sure you check out the "Key Features" section.</span>
<h1>Goals</h1>
	<ul>
		<li>Unified parser for C-based languages<div class="li_desc">We are only focusing on the C languages (C,C++,ObjC); however, if someone wants to work on another language, they are free to take charge of such a project.</div>
		<li>Language conformance with C99, ObjC, C++
		<li>Real-world, production quality compiler
		<li>GCC compatibility
		<li>Library based architecture with finely crafted C++ API’s
			<div class="li_desc">Makes Clang easier to work with and more flexible.</div>
			<div class="li_weak_desc">(more details on this in the "Key Features" section)</div>
		<li>Easy to extend
			<div class="li_weak_desc">(because of the library based architecture)</div>
		<li>Multipurpose
			<div class="li_desc">Can be used for:
			Indexing, static analysis, code generation
			Source to source tools, refactoring</div>
			<div class="li_weak_desc">(because of library based architecture)</div>
		<li>High performance
			<div class="li_desc">Faster than GCC (parse time), Low memory footprint, lazy evaluation</div>
			<div class="li_weak_desc">(more details in the "Key Features" section)</div>
		<li>Better integration with IDEs
			<div class="li_weak_desc">(more details in the "Key Features" section)</div>
		<li>Expressive diagnostics
			<div class="li_desc">Error reporting and diagnostic messages are more detailed an accurate than GCC.</div>
			<div class="li_weak_desc">(more details in the "Key Features" section)</div>
		<li>BSD License
			<div class="li_desc">Fewer restrictions on developers; allows for use in commercial products.</div>
	</ul>
<h1>Key Features</h1>
There are several key features which we believe will make Clang a compelling alternative.  These features are designed to make things easier for both the compiler developer (people working on Clang and derivative products) and the application developer (those who use Clang/LLVM).
<h2>Library based architecture</h2>
A major design concept for the LLVM front-end involves using a library based architecture.  In this library based architecture, various parts of the front-end can be cleanly divided into separate libraries which can then be mixed up for different needs and uses.  In addition, the library based approach makes it much easier for new developers to get involved and extend LLVM to do new and unique things.  In the words of Chris,
<div class="quote">"The world needs better compiler tools, tools which are built as libraries. This design point allows reuse of the tools in new and novel ways. However, building the tools as libraries isn't enough: they must have clean APIs, be as decoupled from each other as possible, and be easy to modify/extend. This requires clean layering, decent design, and avoiding tying the libraries to a specific use."</div>
Currently, the LLVM front-end is divided into the following libraries:
<ul>
	<li>libsupport - Basic support library, reused from LLVM.
	<li>libsystem - System abstraction library, reused from LLVM.
	<li>libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction, file system caching for input source files. <span class="weak_txt">(depends on above libraries)</span>
	<li>libast - Provides classes to represent the C AST, the C type system, builtin functions, and various helpers for analyzing and manipulating the AST (visitors, pretty printers, etc). <span class="weak_txt">(depends on above libraries)</span>
	<li>liblex - C/C++/ObjC lexing and preprocessing, identifier hash table, pragma handling, tokens, and macros. <span class="weak_txt">(depends on above libraries)</span>
	<li>libparse - Parsing and local semantic analysis. This library invokes coarse-grained 'Actions' provided by the client to do stuff (e.g. libsema builds ASTs). <span class="weak_txt">(depends on above libraries)</span>
	<li>libsema - Provides a set of parser actions to build a standardized AST for programs. AST's are 'streamed' out a top-level declaration at a time, allowing clients to use decl-at-a-time processing, build up entire translation units, or even build 'whole program' ASTs depending on how they use the APIs. <span class="weak_txt">(depends on libast and libparse)</span>
	<li>libcodegen - Lower the AST to LLVM IR for optimization & codegen. <span class="weak_txt">(depends on libast)</span>
	<li><b>clang</b> - An example driver, client of the libraries at various levels. <span class="weak_txt">(depends on above libraries, and LLVM VMCore)</span>
</ul>
As an example of the power of this library based design....  If you wanted to build a preprocessor, you would take the Basic and Lexer libraries. If you want an indexer, you would take the previous two and add the Parser library and some actions for indexing. If you want a refactoring, static analysis, or source-to-source compiler tool, you would then add the AST building and semantic analyzer libraries.
In the end, LLVM's library based design will provide developers with many more possibilities.

<h2>Speed & Memory</h2>
Another major focus of LLVM's frontend is speed (for all libraries).  Even at this early stage, the LLVM front-end is quicker than gcc and uses less memory.<br>
<div class="img_container">
	<div class="img_title">Memory:</div>
	<img src="feature-memory1.png" />
	<div class="img_desc">This test was run using Mac OS X's Carbon.h header, which is 12.3MB spread across 558 files!
	Although this is one of the worst case scenarios for GCC, it shows how clang's implemenation is significantly more memory efficient.
	</div>
	<div class="img_notes"><span>Notes:</span>
	Most of the additional memory used by GCC is due to extra data that is added in, which is not needed by the Clang front-end.
	</div>
</div>
<div class="img_container">
	<div class="img_title">Performance:</div>
	<img src="feature-compile1.png" />
	<div class="img_desc">Even at this early stage, the C parser for Clang is able to achieve significantly better performance.
	</div>
</div>
<div class="img_container">
	<div class="img_title">Performance:</div>
	<img src="feature-compile2.png" />
	<div class="img_desc">By moving to distributed compiling using distcc, the performance improvement also becomes noticeable.</div>
	<div class="img_notes"><span>Notes:</span>
	These are SPEC2006 benchmarks using Distcc.</div>
</div>

<h2>More Expressive Diagnostics</h2>
The design of the Clang driver (one of the LLVM front_end libraries) provies more detailed diagnostic information.<br>
<div class="img_container">
	<div class="img_title">Clang vs GCC:</div>
	<img src="feature-diagnostics1.png" />
	<div class="img_desc">There are several things to take note of in this example:
	<ul>
		<li>The error messages from Clang are more detailed.
		<li>Clang shows you exactly where the error is, plus the range it has a problem with.
	</ul>
	</div>
	<div class="img_notes"><span>Notes:</span>The first results are from clang; the second results are from gcc.</div>
</div>
<h2>Better Integration with IDEs</h2>
Another benefit of Clang is that it was designed to integrate better with IDEs. In IDEs, the more information the IDE can get to, the better. The clang driver already provides more detailed (and useful) information than gcc.  However, because of the library based design of LLVM, you can access additional information by mixing and matching parts of the library to create specialized development and debug tools.  In this sense, LLVM is friendlier towards IDEs.
</div>
</body>
</html>