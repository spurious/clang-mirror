<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
  <title>Clang - Features and Goals</title>
  <link type="text/css" rel="stylesheet" href="menu.css" />
  <link type="text/css" rel="stylesheet" href="content.css" />
  <style type="text/css">
</style>
</head>
<body>

<!--#include virtual="menu.html.incl"-->

<div id="content">

<h1>Clang - Features and Goals</h1>
<p>
This page describes the <a href="index.html#goals">features and goals</a> of
Clang in more detail and gives a more broad explanation about what we mean.
These features are:
</p>

<ul>
<li><a href="#real">A real-world, production quality compiler</a></li>
<li><a href="#unifiedparser">A single unified parser for C, Objective C, C++,
    and Objective C++</a></li>
<li><a href="#conformance">Conformance with C/C++/ObjC and their
    variants</a></li>
</ul>

<!--=======================================================================-->
<h2><a name="real">A real-world, production quality compiler</a></h2>
<!--=======================================================================-->

<p>
Clang is designed and built by experienced commercial compiler developers who
are increasingly frustrated with the problems that <a 
href="comparison.html">existing open source compilers</a> have.  Clang is
carefully and thoughtfully designed and built to provide the foundation of a
whole new generation of C/C++/Objective C development tools, and we intend for
it to be commercial quality.</p>

<p>Being a production quality compiler means many things: it means being high
performance, being solid and (relatively) bug free, and it means eventually
being used and depended on by a broad range of people.  While we are still in
the early development stages, we strongly believe that this will become a
reality.</p>

<!--=======================================================================-->
<h2><a name="unifiedparser">A single unified parser for C, Objective C, C++,
and Objective C++</a></h2>
<!--=======================================================================-->

<p>Clang is the "C Language Family Front-end", which means we intend to support
the most popular members of the C family.  We are convinced that the right
parsing technology for this class of languages is a hand-built recursive-descent
parser.  Because it is plain C++ code, recursive descent makes it very easy for
new developers to understand the code, it easily supports ad-hoc rules and other
strange hacks required by C/C++, and makes it straight-forward to implement
excellent diagnostics and error recovery.</p>

<p>We believe that implementing C/C++/ObjC in a single unified parser makes the
end result easier to maintain and evolve than maintaining a separate C and C++
parser which must be bugfixed and maintained independently of each other.</p>

<!--=======================================================================-->
<h2><a name="conformance">Conformance with C/C++/ObjC and their
 variants</a></h2>
<!--=======================================================================-->

<p>When you start work on implementing a language, you find out that there is a
huge gap between how the language works and how most people understand it to
work.  This gap is the difference between a normal programmer and a (scary?
super-natural?) "language lawyer", who knows the ins and outs of the language
and can grok standardese with ease.</p>

<p>In practice, being conformant with the languages means that we aim to support
the full language, including the dark and dusty corners (like trigraphs,
preprocessor arcana, C99 VLAs, etc).  Where we support extensions above and
beyond what the standard officially allows, we make an effort to explicitly call
this out in the code and emit warnings about it (which are disabled by default,
but can optionally be mapped to either warnings or errors), allowing you to use
clang in "strict" mode if you desire.</p>

<p>We also intend to support "dialects" of these languages, such as C89, K&amp;R
C, C++'03, Objective-C 2, etc.</p>

<!--=======================================================================-->
<h2>Library based architecture</h2>
<!--=======================================================================-->

A major design concept for the LLVM front-end involves using a library based architecture.  In this library based architecture, various parts of the front-end can be cleanly divided into separate libraries which can then be mixed up for different needs and uses.  In addition, the library based approach makes it much easier for new developers to get involved and extend LLVM to do new and unique things.  In the words of Chris,
<div class="quote">"The world needs better compiler tools, tools which are built as libraries. This design point allows reuse of the tools in new and novel ways. However, building the tools as libraries isn't enough: they must have clean APIs, be as decoupled from each other as possible, and be easy to modify/extend. This requires clean layering, decent design, and keeping the libraries independent of any specific client."</div>
Currently, the LLVM front-end is divided into the following libraries:
<ul>
<li>libsupport - Basic support library, reused from LLVM.
<li>libsystem - System abstraction library, reused from LLVM.
<li>libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction, file system caching for input source files. <span class="weak_txt">(depends on above libraries)</span>
<li>libast - Provides classes to represent the C AST, the C type system, builtin functions, and various helpers for analyzing and manipulating the AST (visitors, pretty printers, etc). <span class="weak_txt">(depends on above libraries)</span>
<li>liblex - C/C++/ObjC lexing and preprocessing, identifier hash table, pragma handling, tokens, and macros. <span class="weak_txt">(depends on above libraries)</span>
<li>libparse - Parsing and local semantic analysis. This library invokes coarse-grained 'Actions' provided by the client to do stuff (e.g. libsema builds ASTs). <span class="weak_txt">(depends on above libraries)</span>
<li>libsema - Provides a set of parser actions to build a standardized AST for programs. AST's are 'streamed' out a top-level declaration at a time, allowing clients to use decl-at-a-time processing, build up entire translation units, or even build 'whole program' ASTs depending on how they use the APIs. <span class="weak_txt">(depends on libast and libparse)</span>
<li>libcodegen - Lower the AST to LLVM IR for optimization &amp; codegen. <span class="weak_txt">(depends on libast)</span>
<li>librewrite - Editing of text buffers, depends on libast.</li>
<li>libanalysis - Static analysis support, depends on libast.</li>
<li><b>clang</b> - An example driver, client of the libraries at various levels. <span class="weak_txt">(depends on above libraries, and LLVM VMCore)</span>
</ul>
As an example of the power of this library based design....  If you wanted to build a preprocessor, you would take the Basic and Lexer libraries. If you want an indexer, you would take the previous two and add the Parser library and some actions for indexing. If you want a refactoring, static analysis, or source-to-source compiler tool, you would then add the AST building and semantic analyzer libraries.
In the end, LLVM's library based design will provide developers with many more possibilities.

<h2><a name="performance">Speed and Memory</a></h2>
Another major focus of LLVM's frontend is speed (for all libraries).  Even at this early stage, the clang front-end is quicker than gcc and uses less memory.<br>
<div class="img_container">
	<div class="img_title">Memory:</div>
	<img src="feature-memory1.png" />
	<div class="img_desc">This test was run using Mac OS X's Carbon.h header, which is 12.3MB spread across 558 files!
	Although large headers are one of the worst case scenarios for GCC, they are very common and it shows how clang's implemenation is significantly more memory efficient.
	</div>
</div>
<div class="img_container">
	<div class="img_title">Performance:</div>
	<img src="feature-compile1.png" />
	<div class="img_desc">Even at this early stage, the C parser for Clang is able to achieve significantly better performance.  Many optimizations are still possible of course.
	</div>
</div>
<div class="img_container">
	<div class="img_title">Performance:</div>
	<img src="feature-compile2.png" />
	<div class="img_desc">By using very trivial file-system caching, clang can significantly speed up preprocessing-bound applications like distcc.	<span class="img_notes">(<a href="clang_video-07-25-2007.html">more details</a>)</span>
</div>
</div>

<h2><a name="expressivediags">Expressive Diagnostics</a></h2>
Clang is designed to efficiently capture range information for expressions and statements, which allows it to emit very detailed diagnostic information when a problem is detected.<br>
<div class="img_container">
	<div class="img_title">Clang vs GCC:</div>
	<img src="feature-diagnostics1.png" />
	<div class="img_desc">There are several things to take note of in this example:
	<ul>
		<li>The error messages from Clang are more detailed.
		<li>Clang shows you exactly where the error is, plus the range it has a problem with.
	</ul>
	</div>
	<div class="img_notes"><span>Notes:</span>The first results are from clang; the second results are from gcc.</div>
</div>
<h2>Better Integration with IDEs</h2>
Another design goal of Clang is to integrate extremely well with IDEs. IDEs often have very different requirements than code generation, often requiring information that a codegen-only frontend can throw away.  Clang is specifically designed and built to capture this information.
</div>
</body>
</html>
